# FxxkCpp
学习C++本是逆天行道，死在路上很正常

---------
`::` 表示作用域。每个操作数都有一个类型。

P.3 [[Fuck C++]] 头文件名用 `< >` 表示是系统头文件，用 `" "` 括起来代表非系统头文件，非系统头文件的查找从源文件所在位置开始。

`std::endl`为一个控制器，如果将一个控制器写入到流中，那我们就可以控制这个流。

```
\n 换行
\b 回退
\t 水平制表符
\" 转译"
\' 转译'
\\ 转译\
```

缓冲区是用来优化输出操作的，，为了减少每一个输出请求的写操作对系统的开销，库使用缓冲区来累积待写的字符。

字符串和字面值的关系：字符串是字符字面值数组

常量在定义时必须初始化。

`char` 用于保存普通字符
`wchar_t` 用于保存“宽字符”，例如保存日语字符。

使用 `string::size_type` 来定义迭代得次数的类型，int 类型的大小为 32767，如果一个字符串的长度太长，就有可能超出 int 类型的大小，而 `size_type` 是一个无符号整型，保持特定数据结构的大小，养成良好的习惯。

使用命名空间 `using namespace std` 省略重复得 `std::` 

`++i、i++` 更倾向于使用前置操作符的原因：
> 前置操作符只需要加 1 后返回加 1 后的结果，后置操作符必须先保存操作数原来的值，以便返回未加 1 之前得值作为操作的结果。

[C++中 ++i与i++的效率比较\_CC专栏-CSDN博客](https://blog.csdn.net/oktears/article/details/19416609)
[标题：C++里i++与++i的效率与区别 (mallocfree.com)](https://www.mallocfree.com/interview/cpp-15-ipp.htm)
对于内置数据类型，`++i`和`i++`的效率一致，对于自定数据类型，前置操作符重载函数使用的是引用，后置操作符会创建一个临时变量保存当前的值，所以效率更低。

区别：`i++`返回`i`的值，它是一个临时变量，故不能做左值，`++i`返回的是`i+1`后的引用，可以作为左值。
`i++`：取 i 的地址，将它的值放入寄存器中，增加内存中 i 的值。
`++i`：取 i 的地址，将它的值增加后放入寄存器中。循环内部直接用内存中得值就可以，不需要从寄存器中取当前需要得值。
```
mov eax,dword ptr [i]
add eax,1
mov dword ptr [i],eax
```
底层代码会把两种后置操作符优化为前置操作符的形式。对于 int 类型编译器可能会帮我们优化额外得工作，但是对于复杂得数据类型就会增加额外得负担。

`for(int i = 0; i != vec.size(); ++i)`为什么使用 `!=` 而不是 `<` 来比较
> 这反映了一种良好的编程习惯，在C++中，有些数据类型（如vector）可以动态增长，而在循环中容易地增加新元素，如果确实增加了新元素的话，那么测试提前保存的size值就会有问题。在C++函数中有些函数可以声明为内联函数。编译器遇到内联函数时就会直接扩展相应代码，而不是进行实际的函数调用。像size这样的库函数几乎都定义为内联函数，故每次循环过程中调用它的运行时代价是比较小的。

简单来说，数据结构得大小可能动态变化，使用内联函数方便快捷，代价小。

## 第三章
P.37 头文件
```c++
streamsize prec = cout.precision();
cout << setprecision(3) << 0.8768 * 2 << setprecision(prec) << endl;
```
- \<ios>:定义了一个类型 streamsize，输入输出库就是用这个类型来表示长度的。
- \<iomanip>:包含控制器 setprecision，指明输出所包含的有效位数。

`typedef`可以用来取别名，例如`typedef vector<int>::size_type vec_i_sz`

 ## 第四章
 头文件声明的时候使用完整的命名空间而不使用`using`声明的原因：我们无法得知用户希望通过何种方式（在某种情况下可能和用户使用相同的方法但是不再同样的命名空间
 
 预处理程序
 ```c++
 #ifndef 一个预处理程序变量的名称
 
 #define ......
 //一些函数声明
 
 #endif
 ```
 在这个文件第一次被调用的时候，`#ifndef` 指令就会请求预处理程序对在它和下一个匹配的`#endif`之间所有的内容做出适当的处理动作。当我们将头文件第一次包含进去之后，再次尝试将头文件包含进去就无效了。
 
 让预处理程序保持在文件的第一行，注视也不能在预定义之前。
 
 
 常见的异常类
 - logic_error
 - domain_error
 - invalid_argument
 - length_error
 - out_of_range
 - runtime_error
 - range_error
 - overflow_error
 - underflow_error

## 第五章
迭代器有两种类型：`container_type::const_iterator`，当只需要读操作使用常量迭代器，`container_type::iterator`支持读写

vector 迭代器会在向量添加和删除元素后失效，添加新元素后可能导致整个 vector 重新分配

\<cctype>头文件中定义了`isspace`，检查字符是不是空白`\t \n`空格等
```C++
//包含的其它有用的函数
isspace(c) 空白字符 true
isalpha(c) 字母字符 true
isdigit(c) 数字字符 true
isalnum(c) 字母或数字 true
ispunct(c) 标点字符 true
isupper(c) 是大写 true
islower(c) 是小写 true
toupper(c) 变大写
tolower(c) 变小写
```

## 第七章
### 左值、右值、左值引用和右值引用
[理解 C/C++ 中的左值和右值 | nettee 的 blog](https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/)
> 粗略定义：**左值 (lvalue, locator value)** 表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。
**右值 (rvalue)** 右值是一个 _不_ 表示内存中某个可识别位置的对象的表达式。

但是在出现了 const 修饰符之后左值不再是可以修改的。可赋值的左值被称为 _可修改左值 (modifiable lvalues)_ 。左值可以隐式的转换为右值
```c++
int a = 0;//a 是左值
int b = 2;//b 是右值
int c = a+b;// + 需要右值，所以a和 b 被转换为右值
```
右值不可以隐式的转换为左值。

## 第八章 泛型算法
> 泛型算法：可以操作在多种容器类型上，实现同样的操作。

为什么需要泛型算法？
答：因为标准程序库没有给容器涉及很功能函数，如果需要对于不同容器使用相同的操作，在不忽略容器元素类型的情况下就需要设计很多对应元素类型的算法。不同类型的对象可以享有共同的行为特性

大多数是通过两个迭代器来实现的。独立于算法的容器，不依赖于容器存储元素的元素类型。

如何实现泛型函数 -> 使用迭代器 -> 什么是迭代器？ -> 五种类型的迭代器

```c++
template <class T> //模版头，告诉系统环境这里定义的是一个模版
T median(vector<T> v){
    typedef typename vector<T>::size_type vec_sz;

    vec_sz size = v.size();
    if(size == 0) throw domain_error("median of empty vector");

    sort(v.begin(), v.end());
    vec_sz mid = size/2;
    return size%2 == 0 ? (v[mid] + v[mid-1])/2 : v[mid];
}
```

编译器是如何处理模版实例化的：C++标准没有说明系统环境如何对模版的实例化进行处理。应该记住两点
1. 沿用了传统编辑-编译-链接模式的系统环境来说，实例化操作经常不是在编译器见而是在链接期间发生的。只有模版被实例化时，系统环境才能证实，模版代码被用于指定的类型。因此在链接期间，我们就能发现在编译期间可能出现的错误。
2. 只有对自己编写的模版才考虑这一点，模版的定义（不仅是声明）必须是系统环境可以访问的。

算法**永不**执行容器提供的操作，使用泛型算法必须包含`algorithm`头文件

- 输入迭代器 顺序只读访问
	- 一个序列的元素提供了顺序只读访问操作的迭代器应该支持`++(前缀和后缀)、==、!=、解引用*、iter->member`
- 输出迭代器 顺序只写访问
	- 同上第一条
	- 不能对迭代器的两个复制运算之间执行超过一次的++it操作，也不能在没有对迭代器it进行递增的情况下对it进行多次赋值
-  正向迭代器 顺序读-写访问 
	-  正向迭代
		-  `*it`用于读写
		-  `++it` 和 `it++` （不用支持--it和it--）
		-  `it == j `和 `it != j`
		- `it -> member`
- 双向迭代器 可逆访问
	- 支持正向迭代
	- 支持反向迭代
- 随机访问迭代器 随机访问 
	- 双向迭代
	- `p+,p-n,n+p`
	- `p-q`
	- `p[n]` 与`*(p+n)`等价
	- `p<q, p>q, p<=q, p>=q`

## 第九章
[Struct和Class的区别](https://blog.csdn.net/yuechuxuan/article/details/81673953?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242)
在 c++中 struct 可以有成员函数，可以继承，可以多态，在 c 中 struct 只是一种数据结构，因而不能有成员函数。

struct和 class 最大的区别就是访问控制权限，struct 默认是 public，class 默认的访问控制权限是 private。对于访问控制字段最好明确的在代码中指出，养成良好的编码习惯

构造函数：特殊的成员函数，不能显式的被调用，在创建一个对象时，构造函数会自动调用。构造函数的名字和类名一致，没有访问控制符
不带参数的构造函数被认为是默认构造函数。

```c++
class Student_info{
public:
	Student_info();
	Student_info(std::istream&);
};

Student_info::Student_info(): midterm(0),finalterm(0){}
Student_info::Student_info(istream& is){read(is)};

```

## 第十章 管理内存与低级数据结构
指针和数组密不可分，我对指针的理解比较简单，常用的两个符号`&`取地址符，`*`解引用可以取得内存空间中的值。

常量0是唯一可以转化成指针类型的整型值，这种指针类型为空指针。

如果一个函数以另外一个函数为参数，编译器会将这个函数参数转换成一个指向函数的指针。

```c++
bool is_negative(int n){
	return n < 0;
}

vecto<int>::iterator it = find_if(v.begin(), v.end(), is_negative); //这里的is_negative是一个指向函数的指针，也可以写成&is_negative，编译器会自动将函数名转化成指向函数的指针
```

数组名表示指向数组首元素的指针，统一数组中的两个指针进行运算，比如`p+q、p-q`会得到一个整数，它的类型为`ptrdiff_t`

声明为`static`的变量具有全局寿命，生命周期贯穿了整个函数调用过程，只进行一次初始化

**为什么C++程序的入口设计为`int main(){int argc,char *argv[]}`，其中参数的含义** p.185
`argv` 是指向一个数组首元素地址的指针，数组中的每个元素都指向一个字符串参数。
`argc`的值是`argv`指向的数组中的指针个数。`argv`数组的首元素总是`main` 函数编译后的程序名。所以`argc`至少是 1

标准错误流
`cerr` `clog`进行标准错误流的输出，`cerr`流是即时输出错误信息，`clog`类似`cout`平时存储错误信息，在系统认为适当时将他们输出

## 十一章
`explicit` 如果声明一个构造函数的访问修饰符是explicit，显示的使用构造函数才会调用它。

类型定义
- value_type
- reference 同义词 value_type&
- const_reference 同义词 const value_type&
- difference_type 迭代器相互减1后得到的结果类型

复制控制：由类来控制对象被创建、复制、赋值以及删除时具体做什么操作 P.216

重载运算符：必须有一个函数名，带几个参数，并指定返回的数据类型，将运算符放在关键字 operator 后面，

this关键词只在成员函数内部才有效，代表指向函数操作的对象的指针。赋值操作，this总是指向左操作数，在需要指向对象本身的时候用this关键字。
 
赋值总是删除一个旧的值，而初始化没有这个操作。

赋值不是初始化：构造函数始终只是控制初始化操作，operator=成员函数只控制赋值操作

析构函数：由它来定义如何删除该类的一个对象实例。在类的名称前加~。不带有任何参数，没有返回值。


## 第十二章 虚函数和动态绑定
`protected`关键字为派生类赋予了访问基类中保护乘员的权利，同时又能够继续使这些成员不被类的其他使用者所使用。私有成员只有类的友元可以访问。

编译器是如何生成一个派生类对象的：
- 为整个对象分配内存空间（包括基类与派生类中定义的数据）
- 调用基类的构造函数以便初始化对象中的基类部分数据
- 使用构造初始化器对对象的派生类部分数据进行初始化
- 如果有的话，执行派生类构造函数的函数体

**虚函数**实现动态绑定。
假定基类A和派生类B，B中重定义了A中的C函数，在D函数中我们需要比较对象A a和对象B b的C函数的返回值，如果使用一个确定了参数类型的`D(const A& i, const A& j)`来说，如果传递了对象b，那么函数就会报错，所以我们需要在实际传递参数类型的时候来运行正确的C函数，那么就可以使用`virtual`虚函数。
只有在以引用或指针作为参数调用虚函数时，它在运行时的选择特性才有意义。因为引用或指针指向对象的实际类型在运行时是可以变化的。

动态绑定：指运行时才决定调用什么函数，而不是在编译的时候就决定下来，后一种属于静态绑定。

多态性(polymorphism)：指 用一个类型表示几种类型的能力，C++通过虚拟函数的动态绑定以支持多态性

------
Reference:
[[C++]]
[[Fuck C++]]
[[C++11特性]]